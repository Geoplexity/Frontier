/*This part includes
1)
checks for rot-sym in simplify cluster, distribute
cluster/pushoutside, addchild, cancombine

2)
bananas checks, edge addition and correction within clusmin
adding ordering of clusters in dr plan

3)
groups distributeforest, distributegroup, etc.

This is the completed version. It contains the simple version.
*/

augment(Vertex v, Edge edgep)
Begin
	//wt is the largestweight of flow which can be increased to v.
	wt = min(vp.PosFlow, vp.weight - vp.EstFlow);
	edgep.incrsPosFlow(-wt);
	e = v.PredEdge;
	while (e != NULL)
		//increase the relevant flow of e to v
		if e has no previous vertex, get out of loop
		else
			change the relevant flow of previous vertex of e.
			set e to the previous edge of v.
	endwhile
endBegin	

//distribute the weight of edge in F. If return 0, distribute successfully.
//If return 1, failed
distribute0(Edge edge)
Begin
	remove all labels of vertices and edges of the graph;
	while there is vertex or edge which has not been scaned and edge still has some flow left
		for all labeled e that has not been scaned in F
			label unlabeled neighbors of e;
			set their possible flow same as e;
		for every labeled vertex v in F
			if (v has the capacity left)
				augment(vp, edgep);
				removeLabels();
				if (edge still has possible flow left)
					label the edge;
			else
				label all the unlabeled edges incident to v;
				set their possible flow equal the minimal one of the possible folw of v and the flow e to v.
	if distribute successfully, return 0;
	else restore the flowes have been distributed, return 1;
endBegin

int distributeEdge(Edge edge, Graph F)
Begin 
	//distribute the edge with original weight
	a = F.distribute0(edge);
	if (a == 1) return 1;
	//if we can distribute it, we try to distribute the
	//ege with weight K.
	else
		make CF be the copy of F;
		edge.setWeight(K);
		a = CF.distribute0(edge);
		if ( a == 1)
			copyLabel(CF,F);
			return 2;
	return 0;
endBegin

//distribute a single vertex
Cluster distributeVertex(Vertex v1, Graph F, Graph G)
Begin
 	append v1 to F;
	//visit all the vertices of F.
	for every vertex v2 in F
		if (the edge which connect v1 and v2 exists and has not been distributed) 
			k = distributeEdge(edge, F, G);
		if (k>0)
			if the number of labeled vertices in F is bigger than F's dimension
                    		newTree = getCluster(F, G);
                      		return newTree;				
			else if (extension(F, G)) 
                    		newTree = getCluster(F, G);
                      		if (newTree != null) return newTree;				
	endfor
	return an empty cluster
endBegin

//After distribute has been run, Graph F contains vertices labeled for the creation of a new cluster
//this method isolates those vertices, performs any reductions to the interior vertices and edges 
//as necessary, and creates a new Cluster object, returning a pointer to it
getCluster(Graph F, Graph G)
Begin 
	for every labled vertex vOld in F
		append vOld to originalV;
		if (vOld has the outer edge)
			append vOld to frontiers;
		else
			append vOld to the innerV;
	append the edges whose both ends are frontier vertices to outerE;
	form the new edge which connects the core and the frontier vertices;
	append it to innerE;
	core's weight = the total weight of outer edges + inner edges - frontier vertices + K.// K is 3 for 2D, 6 for 3D
	form new_cluster based on core, frointiers, innerE, outerE, originalV
	return new_cluster;
endBegin

distributeCluster(Cluster &C, Graph &F)
Begin
	defrost all frontier vertices and add c's core to F;
	//distribute outer edges which have no flow in F
	for each e which connects 2 frontier vertices of C
		if(e has no flow in F) distributeEdge(e, F);
	//distribute inner edges
	for each e which connects one frontier vertex and one inner vertex
		distributeEdge(e, F);
	divide the K-1 weight among inner edges. (k - 2 for rot-sys cluster)
	for every inner edge e in F.		 //make C dense
		distributeEdge(e, F);
endBegin

int pushOutside(Cluster &C, Graph &F, Graph &graph0)
Begin
	copyG(F, CF);
   	for every frontier vertices
          	select a non-inner targetEdge e which has no flow in CF
 	  	delete it from F;
		if(!distributeEdge(e, F))
	        	return 1;
		delete it from CF and set its weight to 1. (2 for rot-sys cluster)
		if(!distributeEdge(e, CF))
			copyLable(CF, F) and return 1;
	return 0;	//failed
endBegin

//Banana correction function is called implicitly in this function.
Cluster clusmin(Cluster &c, List<Cluster> children)
Begin
	List<Cluster> E, C', newChildren, resultOfE; //essential clusters
	bool found_flag = false;
	
	if(number of c's children == 2)
		return c;
	while(found_flag == false && resultOfE.size != 1) 
		for each cluster Ci in children
			Graph g = the subgraph without Ci or the clusters of E;
			C' = distributeForest(g);
			if(C'.size == 1)	//found a cluster
				found_flag = true;
				newChildren = part of children which doesn't contain elements of C';
				newChildren = the union of C' and newChildren;
			else
				E.append(Ci);
		resultOfE = distributeForest(E);
	//no change to C's children
	if(resultOfE.size > 1)
		return C;	
	if(fould_flag)
		return clusmin(C, newChildren);
	else
		newChildren = part of children wich doesn't contain elements of E;
		newChildren = the union of resultOfE and newChildren;
		return  clusmin(C, newChildren);
endBegin

//refer the write-up 3.1
void addChild(Cluster &newTree, List<Cluster> &popedTrees, List<Cluster> &DR_Trees, Graph &F, Graph &graph0)
Begin
	nameList=newTree.returnOrig(); //vertex name list forms a new cluster
	//check each item (not poped) left in DR_Trees with the name list
	explicitChild(newTree, nameList, DR_Trees);
	// check each poped item with the name list
	explicitChild(newTree, nameList, popedTrees);
	// look implicit child in DR_Trees
	implicitChild(newTree, nameList, DR_Trees, F, graph0);
	// look implicit child in popedTrees
	implicitChild(newTree, nameList, popedTrees, F, graph0);
	create a new cluster based on the left vertices in namelist and append it to newTree
endBegin

//refer the write-up 3.1.to check whether c and c10 can be combined
bool canCombine (Cluster &c, Cluster &cl0, Graph &F, Graph &graph0)
Begin
	overlappedVerts = the overlapped vertices of c and cl0;
	if no overlapped vertex, return false;
	//refer to the write-up 2.2, addchild part
	lenIndepent = the number of subsets of overlapped vertices which is not incident to the others;
	if(lenIndepent < 2) return false;
	if(F.returnDimen() == 2) return true;
	//3D
	if(lenIndepent == 2) return true;
	DR_Trees=distributeForest(overlappedVerts);
 	getTrivial(DR_Trees, F1);
 	//DR_Trees is a forest
	if(DR_Trees.returnLen() > 1) return true;
	//DR_Trees is a cluster
 	if DR_Trees is not type 2, return true;
	else if either of c or c10 is type2, return true;
	else if there is non-incidence edge between c and c10 && the edge is not contained in overlapped part,
		return true;
	else
		return false;
endBegin

//achild is contained totally in the newtree	
void explicitChild(Cluster &newTree, Graph F, List<int> &nameList,List<Cluster> &forest)
Begin
 	for every cluster aChild in forest
          	aChild=popMaxDepth(forest);
          	if(isCoreIn(newTree, aChild) 
                  	delete all the original vertices of achild from namelist;
                  	add them to the original vertices of newTree;
                  	combineFlow(newTree, aChild, F);
                  	append achild to newTree's children;
                else
                 	tempTrees.append(aChild);
   	forest=tempTrees;
endBegin

void implicitChild(Cluster &newTree, List<int> &nameList, List<Cluster> &forest, Graph &F, Graph &graph0)
Begin
 	for every cluster aChild in forest
         	aChild=popMaxDepth(forest);
          	if(canCombine(aChild, newTree))   // achild and newTree can form a new cluster
                    	append the core vertices and inner edges of achild and newTree to F.(all labled 1)
                  	temp=getCluster(F, graph0);
			newTree.formCl(temp);
			delete all the original vertices of achild from namelist;
			add them to the original vertices of newTree;
			append achild to newTree's children;
          	else
                 	tempTrees.append(aChild);
   	forest=tempTrees;
endBegin

//Distribute all the clsuters in DR_Trees assuring that the groups set by the user and found in the output
//DR_Dag.  Both distributeForest and distributeTree work recursively together to perform this process
distributeTree(Cluster Tree, Graph F, Graph G)
Begin
	if (Tree is a single vertex) return Tree;
	distriedChild = distributeForest(Tree.Children, F, G);
	if (distriedChild is a tree)
		newDRTree = distriedChild;
	else
		newDRTree.Children = distriedChild;
	return *newDRTree;
endBegin

//Mark the edge which has flow towards the group. refer to the write-up 3.5
markEdges(List<Cluster> DR_Trees, Graph G);
Begin
	for each e in G
		if(only one end vertex of e is frozen && e has flow w to the unfrozen end vertex)
			e.setMark(w);
		if(both end vertices of e are unFrozen && e has undistributed flow w)
			e.setMark(w);
endBegin

distributeForest(List<Cluster> DR_Trees, Graph F, Graph G, int groupID)
Begin
	for each tree T in DR_Trees //distribute the trees in forest
		C1=DistributeTree(T, G);
		if (C1 is not empty)
			DR_Trees.append(C1);
	if DR_Trees has only one element, return DR_Trees;
	//Groups. (STEP 1, 2 & 3 ARE PROCEEDED)
	if (groupID!=0)       
		for each child group g of it
			distributeGroup(G, F, DR_Trees, g.groupID());
	//STEP 4: MFA PROCEEDS AS USUAL
   	while (DR_Trees.returnLen() > 0 )
		C2 = F.popMinDepth();
		C3 = DistributeC1(C2, G);
		if( C3 is not empty)
			addChild(C3, popedTrees, DR_Trees, F, graph0);
			if (!checkClusterForBananas(graph0, C3))
				throw away C3.
			else
				F.append(C3);
		if (number of Clusters in F==1 and no cluster in G)
			return F; //the whole graph is dense
	combine the flows.
	return G; // the whole graph is not dense
endBegin

//this method contains step 1, 2 & 3 and is called in distributeForest
distributeGroup(Graph &graph0, Graph &Flowgraph, List<Cluster> Cqueue, int groupID)
Begin
	List<Cluster> localCqueue;
	Graph localF = Flowgraph;
	i = checkGroupCases(graph0, groupID); 	//check which cases it belongs to. refer to the document
	//STEP1
	freeze(g);			//freeze the outer part of g
	if(i == 3)
		localF.makeEmpty();	//create empty flow graph for case 3
	if(i == 2)
		markEdges(F);		//mark the edge which has in-flow for case 2
	//STEP2
	distributeForest(graph0, localF, localCqueue, groupID);	
	//STEP3
	combineGroups(graph0, localCqueue, Cqueue, localF, Flowgraph, i);	//refer the document for details
endBegin	

//STEP3. Refer to write up for details
combineGroups(Graph &graph0, List<Cluster> localCqueue, List<Cluster> Cqueue, Graph & FlowGraph, int groupType)
Begin
	For each cluster C in Cqueue 
		For each cluster D in localCqueue
			if C can combine D to form a new cluster Cnew.
				put Cnew in Cqueue;
				remove C and D from Cqueue and localCqueue.
				if(groupType == 3)
					for each non-cluster edge e in FlowGraph
						e.setmark();
						remove the flow of e.
endBegin

//refer to the write-up 2.1
getClusterType(Graph &graph0, Cluster &theCluster)
Begin
	if it has no imaginary object and 2 or more distance constraints, return 0;
	//refer to the write-up 2.2, rot-sym part
	if it has no non-incidence edges between child clusters and all child is rot-sym, return 2;
	if it has only one distance constraint and 2 3Dpoints, return 2;	//special case
	if it has a line segment and one distance constraint 
		&& every other constraint is an incidence constraint	
		return 2;
	return 0;
endBegin

//refer to the write-up 3.2
bool checkClusterForBananas(Graph &graph0, Cluster &C)
Begin
	if(graph0.returnDimen()==2) return true;
	overlappedVerts = the overlapped part of the children.
	remove the imaginary vertex which is incident to the others in overlappedVerts.
	if the number of children clusters not exactly 2, return true. 
	if either of the children clusters is rot-sym cluster, return true;
	NotIncidParts = the number of sub-parts in overlappedVerts which is not incident to the others
	if NotIncidParts != 2, return true;
	Vertex p1, p2;
	set p1 and p2 be the independent points in overlappedVert;
	if there is one distance edge between p1 and p2
		return true;
	if there is no distance edge between p1 and p2
		if there exists some other edges between p1 and p2
			simplify C to dof 6;
			C.setType(3);   	//mark it as over-constrainted cluster.
			return true;
		else
			add one virtual edge e between p1 and p2;
			simplify all existing clusters which contain e to have dof 6;
			distribute all existing clusters which contain e;
			return false;
endBegin

bool isCoreIn(Cluster newC, Cluster oldC)
Begin
	if(newC.hasVert(oldC.returnCore())) return true;
	vOldCore = oldC.returnOrig();
	for each frontier vertex v in oldC
		vOldCore.delete(v);
	for each vertex v in vOldCore
		if(!newC.hasVert(v)) return false;
	return true;
endBegin

combineFlow(Cluster newC, Cluster oldC, Graph F)
Begin
	vOldCore = oldC.returnOrig();
	for each frontier vertex v in oldC
		vOldCore.delete(v);
	for each vertex v in vOldCore
		combine the flow which concerns v to oldC's Core vertex
		F.delete(v);
endBegin
